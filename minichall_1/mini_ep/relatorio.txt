	Para a implementação desse EP, utilizamos dois mutexes e uma barreira de sincronização: um mutex para
permitir os pulos dos sapos e rãs, um mutex para atualizar o contador global, e uma barreira de sincronização
para garantir que todos os sapos tenham sido criados antes de começarem a pular.
	Primeiro inicializamos todos os sapos e rãs, depois liberamos a barreira de sincronização para que eles tentem
pular. Cada thread tenta fazer primeiramente um pulo de tamanho 1 e depois um pulo de tamanho 2. Quando uma thread
vê que possivelmente pode pular ela usa o mutex 'jump' para fazer a verificação, e caso seja válida ela pula. Ao final
cada thread vê se conseguiu pular ou não e caso tenha conseguido incrementa o contador ou zera caso contrário, sempre
utilizando o mutex counter caso contrário.
	Também fizemos algumas funções auxiliares para nos ajudar a fazer verificações sobre o estado dos
sapos e das rãs. A função 'check_good_state' verifica se os sapos e rãs terminaram em um estado em que as
rãs estão todas na direita e os sapos a esquerda (isto é, invertido). A função 'check_deadlock' verifica se
os sapos e rãs estão em estado de deadlock (isto é, nenhum sapo e nenhuma rã consegue pular).
	Para os testes usamos vetores de tamanho 5, 11 e 101. Para vetores de tamanho 5 percebemos que o limite de 100 falhas
é provalvelmente suficiente para identificar um deadlock, sendo que para vetores de tamanho 11 é 100000 e para vetores de
tamanho 101 é 1000000. Para estimar o contador fizemos varias buscas binárias, para chegarmos em valores aproximados.